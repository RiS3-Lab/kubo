#include "Project.h"
#include <ctime>
#include <future>
// option setup
cl::opt<string> FILTERF("outf", cl::Required,
                        cl::desc("<filter file> Print BBID of basic blocks"
                               "containing false sanitizer label"));
cl::opt<string> CGF("cgf", cl::Required,
                        cl::desc("<call graph file generated by pex> contain the call graph info"));

cl::opt<string> TAINTF("taintf", cl::Required,
                    cl::desc("<taint summary> contain the call graph info"));

cl::opt<string> USRF("usrinputf", cl::Required,
                       cl::desc("<usr input> contain the parameters for the function that directly receive user input"));

cl::opt<string> ENTF("entryf", cl::Required,
                       cl::desc("<usr input> syscall/ioctls"));


//cl::opt<string> ASTF("astf",cl::Required,
//                     cl::desc("outputfile for ast\n"));
// pass info
char KSym::ID = 0;
static RegisterPass<KSym> X("KSym", "Kernel Static Symbolizer", false, true);

// globals
Dumper DUMP;

#ifdef KSYM_DEBUG
Logger SLOG;
#endif

set<Function *> EXCEPT;

// black lists
static const set<string> BLACKLIST({
    // llvm loop construction bug
    string("vmw_execbuf_process"),
    string("do_io_rw"),
    string("i915_gem_do_execbuffer"),
    string("atomisp_cp_general_isp_parameters"),
    // user copying
    string("copy_strings"),
    string("mcopy_atomic"),
    string("strndup_user"),
    // sync
    string("do_futex"),
    string("futex_requeue"),
    // core dump
    string("do_usercopy_stack"),
    string("do_usercopy_heap_size"),
    string("do_usercopy_heap_flag"),
    string("elf_core_dump"),
    string("elf_core_dump.2051"),
    // path explosion
    string("pktgen_if_write"),
    string("pktgen_thread_write"),
    string("cache_alloc"),
    // loop explosion
    string("mptctl_do_fw_download"),
    string("qib_user_sdma_writev"),
    string("snd_emu10k1_icode_poke"),
    string("snd_soundfont_load"),
    string("st_write"),
    string("ip_vs_sync_conn"),
    string("vringh_getdesc_user")
    });

// class kAA
KSym::KSym() : ModulePass(ID) {
  // do nothing
}

KSym::~KSym() {
}
void KSym::getAnalysisUsage(AnalysisUsage &au) const {
  // since we are one-shot pass, simply mark everything is preserved
  // regardless of whether it is actually preserved or not
  ModulePass::getAnalysisUsage(au);
  au.addRequired<TargetLibraryInfoWrapperPass>();
  //au.addRequired<MemoryDependenceWrapperPass>();
  au.setPreservesAll();
}

static inline void ltrim(string &s) {
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](int ch) {
        return !isspace(ch);
    }));
}

// trim from end (in place)
static inline void rtrim(string &s) {
    s.erase(find_if(s.rbegin(), s.rend(), [](int ch) {
        return !isspace(ch);
    }).base(), s.end());
}

// trim from both ends (in place)
static inline void trim(string &s) {
    ltrim(s);
    rtrim(s);
}
static void  parseCheckPoint(string outFileName,vector<string>& ret){
    string buffer;
    FileReader fr = FileReader(outFileName);
    if(!fr.ok())
        return;
    string funcStarter("[info]dealing with func:");
    while(fr.readLine(&buffer))
    {
        if(buffer.find(funcStarter) == 0)
        {
            string fName = buffer.substr(funcStarter.size());
            rtrim(fName);
            ret.push_back(fName);
        }
    }
    return;
}

int MAX_NUM_TRACES_PER_SEED = 128;
int MAX_NUM_SEEDS_PER_FUNC = 50;
int MAX_NUM_CALLSITES_PER_CALLER=10;
int MAX_NUM_CALLERS=10;
// worst case scenario: a buggy function can have 128*50*10*10=640,000 traces, which is too large
// but this doesn't appear too often, and we get prompted when this happens
bool KSym::runOnModule(Module &m) {
    // create module-level vars
    auto &tli = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI();
    ModuleOracle mo(m, tli);
  
    double duration;
    clock_t start = clock();
    string filterF = FILTERF.getValue();


    errs()<<"parsing callgraph...";
    mo.parseCallGraph(CGF.getValue());
    duration = (clock() - start) / (double) CLOCKS_PER_SEC;
    errs()<<"done in "<<duration<<"s\n";


    errs()<<"parsing __user pointer...";
    mo.parseUserInputArg(USRF.getValue());
    errs()<<"done\n";
    
    errs()<<"parsing taint summary...";
    mo.parseTaintSummary(TAINTF.getValue(),false);
    errs()<<"done\n";


    errs()<<"parsing ioctl/syscall functions...\n";
    mo.parseSyscallIoctl(ENTF.getValue());
    errs()<<"done\n";

    errs()<<"parsing sysctl...\n";
    mo.parseSysctl();
    errs()<<"done\n";

    mo.constructSeedMap();
    // run module pass
    breakConstantExpr(m);
  
    // transform intrinsic functions
    cleanIntrinsics(m, m.getDataLayout());
  
    // prepare output filter file if needed
    FileWriter *fw = nullptr;
    //errs()<<filterF<<'\n';
    fw = new FileWriter(filterF);

    int totalFunCount = 0;

    //check point
    vector<pair<string,int>> funcs;
    
    /*
    vector<string> alreadyProcess;
    parseCheckPoint(FILTERF.getValue(),alreadyProcess);
    */
    int num_of_hops = 4;
    vector<Function*> timed_out_func;
    for(Function &f : m){
        string funcName = f.getName().str();
        // ignored non-defined functions
        if(f.isIntrinsic() || f.isDeclaration()){
            continue;
        }
        if(BLACKLIST.find(f.getName().str()) != BLACKLIST.end()){
            continue;
        }
        /*
        if(std::find(alreadyProcess.begin(),alreadyProcess.end(),funcName) != alreadyProcess.end()){
            continue;
        }*/
        string tarFunc("ch_gstatus");
        //if(funcName != tarFunc ) {
        //    continue;
        //}

        string to_write = "[info]dealing with func:"+funcName + "\n";
        fw->writeLine(to_write);
        errs()<<to_write;
        totalFunCount++;


        lowerSwitch(f);
        set<int> user_paras = mo.getUserSpaceArgs(&f);
        SAHandle*  handle = new SAHandle(f, mo, fw,user_paras);
        //MemoryDependenceResults &MDA = getAnalysis<MemoryDependenceWrapperPass>(f).getMemDep();
        start = clock();
        handle->run();
        duration = (clock() - start) / (double) CLOCKS_PER_SEC;
        
        //dump things to the file
        //output confirmed bugs
        // this summarized variable is not necessary, just for compatibility
        map<CallInst*,UBResult> summarized;
        handle->mergeResult(summarized);
        SAHandle::write_result_to_file(mo,fw,summarized);
        handle->write_num_interTrace_to_file();

        errs()<<fmt::format("[info] hop 0 takes {}s for {}\n",duration,funcName);
        fw->writeLine(fmt::format("[info] hop 0 takes {}s for {}\n",duration,funcName));

  
        list<pair<SAHandle*,vector<string> > > calleeList;
  
        calleeList.push_back(make_pair(handle,vector<string>({funcName})));
        int total_callers = 0;
        for(int hop_count = 1; hop_count <= num_of_hops; hop_count++){
            if(calleeList.size() == 0){
                fw->writeLine("all caller finished, analysis end\n");
                break;
            }
            map<CallInst*,UBResult> summarized;
            //accepts next hops
            list<pair<SAHandle*,vector<string> > > calleeList_next;
            int caller_cnt = 0;

            // start the clock for this hop
            start = clock();
            for(auto eachCalleeIt = calleeList.begin();eachCalleeIt != calleeList.end();eachCalleeIt++){
                // process one callee function
                SAHandle* calleeF = eachCalleeIt->first;
                vector<string> processed_funcs = eachCalleeIt->second;
                int calleeTraceNum = calleeF->interPTraces.size();
                if(calleeTraceNum == 0){
                    // this callee has no outside dependencies
                    delete(eachCalleeIt->first);
                    eachCalleeIt->first = nullptr;
                    continue;
                }
                string callee_name = calleeF->getFunc().getName().str();
                assert(callee_name == processed_funcs.back());

                //look for a callers that calls calleeF
                map<Function*,set<CallInst*> > callers;
                set<CallInst*>* callersSet = mo.getCaller(&calleeF->getFunc());
                //there are a bunch of callinst that called calleeF
                if(callersSet != nullptr){
                    for(auto eachCaller = callersSet->begin(); eachCaller != callersSet->end(); eachCaller++){
                        // some call instructions reside in the same function,
                        // group them together
                        Function* callerFunc = (*eachCaller)->getFunction();
                        if(callers.find(callerFunc) == callers.end()){
                            callers[callerFunc] = set<CallInst*>();
                            callers[callerFunc].insert(*eachCaller);
                        }else{
                            if(callers[callerFunc].size() <= MAX_NUM_CALLSITES_PER_CALLER){
                                callers[callerFunc].insert(*eachCaller);
                            }
                        }
                    }
                    for(auto eachCallerFunc = callers.begin(); eachCallerFunc != callers.end(); eachCallerFunc++){
                        Function* cur_caller = eachCallerFunc->first;
                        string caller_name = cur_caller->getName();
                        if(find(processed_funcs.begin(),processed_funcs.end(),caller_name) != processed_funcs.end()){
                            // a recursive call will not bring extra taint, so not interested in the current caller
                            continue;
                        }
                        //get __user paras
                        set<int> user_paras = mo.getUserSpaceArgs(cur_caller);
                        FunctionTaintSummary* taintSum = mo.getFuncSum(cur_caller);
                        if(taintSum ==nullptr){
                            // no callee is tainted by the current caller, thus no need to go in
                            continue;
                        }
                        caller_cnt++;
                        if(caller_cnt > MAX_NUM_CALLERS){
                            fw->writeLine("total_num of callers exceeds");
                            continue;
                        }
                        string to_write = fmt::format("[info]begin to check:{}({})--->{}({})\n",callee_name,hop_count - 1,cur_caller->getName().str(),hop_count);
                        fw->writeLine(to_write);
                        errs()<<to_write;
                        SAHandle* handleInter = new SAHandle(*cur_caller,&(calleeF->getFunc()),\
                        mo,fw,user_paras,eachCallerFunc->second,&calleeF->interPTraces,taintSum,hop_count);
                        handleInter->runInter();
                        /*
                        vector<string> new_processed_funcs(processed_funcs.begin(),processed_funcs.end());
                        new_processed_funcs.push_back(caller_name);
                        calleeList_next.push_back(make_pair(handleInter,new_processed_funcs));
                        handleInter->mergeResult(summarized);
                        */
                        std::future<void> fut = std::async(std::launch::async,&SAHandle::runInter,handleInter);
                        std::chrono::system_clock::time_point one_hundred_seconds = std::chrono::system_clock::now() + std::chrono::seconds(100);
                        if(fut.wait_until(one_hundred_seconds) == std::future_status::ready){
                            vector<string> new_processed_funcs(processed_funcs.begin(),processed_funcs.end());
                            new_processed_funcs.push_back(caller_name);
                            calleeList_next.push_back(make_pair(handleInter,new_processed_funcs));
                            handleInter->mergeResult(summarized);
                        }
                        else{
                            handleInter->timed_out();
                            fut.get();
                            timed_out_func.push_back(cur_caller);
                            handleInter->mergeResult(summarized);
                            delete(handleInter);
                        }
                        total_callers ++;
                    }
                }
                delete(eachCalleeIt->first);
                eachCalleeIt->first = nullptr;
            }
            // make sure all processed functions are freed
            for(auto eachCalleeIt = calleeList.begin();eachCalleeIt != calleeList.end();eachCalleeIt++){
                assert(eachCalleeIt->first == nullptr);
            }
            //write the result of this hop to file across different callers.
            SAHandle::write_result_to_file(mo,fw,summarized);
            set<CallInst*> trueSeeds = SAHandle::aggregateResult(summarized,UB_True);
            set<CallInst*> falseSeeds = SAHandle::aggregateResult(summarized,UB_False);

            // remove true seed from all jobs that's going to be executed next
            for(auto eachCaller = calleeList_next.begin(); eachCaller != calleeList_next.end();eachCaller++){
                SAHandle* next_job = eachCaller->first;
                next_job->remove_seeds_from_interTraces(trueSeeds);
                next_job->remove_seeds_from_interTraces(falseSeeds);
                next_job->write_num_interTrace_to_file();
            }

            // end clock for this hop
            duration = (clock() - start) / (double) CLOCKS_PER_SEC;
            fw->writeLine(fmt::format("[info] hop {} takes {}s for {}, {} callers processed for this hop, {} timed out so far(across different hops) \n"\
                ,hop_count,duration,funcName,calleeList.size(),timed_out_func.size()));

            calleeList.clear();
            calleeList.insert(calleeList.end(),calleeList_next.begin(),calleeList_next.end());
        }
        fw->writeLine(fmt::format("[info] func {} is finished, {} timed out, {} callers in total\n",\
        funcName,timed_out_func.size(),total_callers));
        // this functions and its callers have been finished, release the resources
        for(auto eachCalleeIt = calleeList.begin();eachCalleeIt != calleeList.end();eachCalleeIt++){
            assert(eachCalleeIt->first != nullptr);
            delete(eachCalleeIt->first);
        }
        calleeList.clear();
        __asm__("nop");
    }
    fw->writeLine(fmt::format("totalFunCount:{}\n",totalFunCount));
    // clean up
    if (fw) {
        delete fw;
    }
    return false;
}
